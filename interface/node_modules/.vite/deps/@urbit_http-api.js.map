{
  "version": 3,
  "sources": ["../../@urbit/http-api/src/types.ts", "../../@urbit/http-api/node_modules/browser-or-node/lib/index.js", "../../@urbit/http-api/node_modules/@microsoft/fetch-event-source/lib/esm/parse.js", "../../@urbit/http-api/node_modules/@microsoft/fetch-event-source/lib/esm/fetch.js", "../../@urbit/http-api/src/utils.ts", "../../@urbit/http-api/src/Urbit.ts", "dep:@urbit_http-api"],
  "sourcesContent": ["/**\n * An urbit style path, rendered as a Javascript string\n * @example\n * `\"/updates\"`\n */\nexport type Path = string;\n\n/**\n * @p including leading sig, rendered as a string\n *\n * @example\n * ```typescript\n * \"~sampel-palnet\"\n * ```\n *\n */\nexport type Patp = string;\n\n/**\n * @p not including leading sig, rendered as a string\n *\n * @example\n * ```typescript\n * \"sampel-palnet\"\n * ```\n *\n */\nexport type PatpNoSig = string;\n\n/**\n * The name of a clay mark, as a string\n *\n * @example\n * ```typescript\n * \"graph-update\"\n * ```\n */\nexport type Mark = string;\n\n/**\n * The name of a gall agent, as a string\n *\n * @example\n *\n * ```typescript\n * \"graph-store\"\n * ```\n */\nexport type GallAgent = string;\n\n/**\n * Description of an outgoing poke\n *\n * @typeParam Action - Typescript type of the data being poked\n */\nexport interface Poke<Action> {\n  /**\n   * Ship to poke. If left empty, the api lib will populate it with the ship that it is connected to.\n   *\n   * @remarks\n   *\n   * This should always be the ship that you are connected to\n   *\n   */\n  ship?: PatpNoSig;\n  /**\n   */\n  app: GallAgent;\n  /**\n   * Mark of the cage to be poked\n   *\n   */\n  mark: Mark;\n  /**\n   * Vase of the cage of to be poked, as JSON\n   */\n  json: Action;\n}\n\n/**\n * Description of a scry request\n */\nexport interface Scry {\n  /** {@inheritDoc GallAgent} */\n  app: GallAgent;\n  /** {@inheritDoc Path} */\n  path: Path;\n}\n\n/**\n * Description of a thread request\n *\n * @typeParam Action - Typescript type of the data being poked\n */\nexport interface Thread<Action> {\n  /**\n   * The mark of the input vase\n   */\n  inputMark: Mark;\n  /**\n   * The mark of the output vase\n   */\n  outputMark: Mark;\n  /**\n   * Name of the thread\n   *\n   * @example\n   * ```typescript\n   * \"graph-add-nodes\"\n   * ```\n   */\n  threadName: string;\n  /**\n   * Desk of thread\n   */\n  desk?: string;\n  /**\n   * Data of the input vase\n   */\n  body: Action;\n}\n\nexport type Action = 'poke' | 'subscribe' | 'ack' | 'unsubscribe' | 'delete';\n\nexport interface PokeHandlers {\n  onSuccess?: () => void;\n  onError?: (e: any) => void;\n}\n\nexport type PokeInterface<T> = PokeHandlers & Poke<T>;\n\nexport interface AuthenticationInterface {\n  ship: string;\n  url: string;\n  code: string;\n  verbose?: boolean;\n}\n\n/**\n * Subscription event handlers\n *\n */\nexport interface SubscriptionInterface {\n  /**\n   * Handle negative %watch-ack\n   */\n  err?(error: any, id: string): void;\n  /**\n   * Handle %fact\n   */\n  event?(data: any, mark: string): void;\n  /**\n   * Handle %kick\n   */\n  quit?(data: any): void;\n}\n\nexport type OnceSubscriptionErr = 'quit' | 'nack' | 'timeout';\n\nexport interface SubscriptionRequestInterface extends SubscriptionInterface {\n  /**\n   * The app to subscribe to\n   * @example\n   * `\"graph-store\"`\n   */\n  app: GallAgent;\n  /**\n   * The path to which to subscribe\n   * @example\n   * `\"/keys\"`\n   */\n  path: Path;\n}\n\nexport interface headers {\n  'Content-Type': string;\n  Cookie?: string;\n}\n\nexport interface CustomEventHandler {\n  (data: any, response: string): void;\n}\n\nexport interface SSEOptions {\n  headers?: {\n    Cookie?: string;\n  };\n  withCredentials?: boolean;\n}\n\nexport interface Message extends Record<string, any> {\n  action: Action;\n  id?: number;\n}\n\nexport class ResumableError extends Error {}\n\nexport class FatalError extends Error {}\n", "'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* global window self */\n\nvar isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n\n/* eslint-disable no-restricted-globals */\nvar isWebWorker = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope';\n/* eslint-enable no-restricted-globals */\n\nvar isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n\n/**\n * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0\n * @see https://github.com/jsdom/jsdom/issues/1537\n */\n/* eslint-disable no-undef */\nvar isJsDom = function isJsDom() {\n  return typeof window !== 'undefined' && window.name === 'nodejs' || navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom');\n};\n\nexports.isBrowser = isBrowser;\nexports.isWebWorker = isWebWorker;\nexports.isNode = isNode;\nexports.isJsDom = isJsDom;", "export async function getBytes(stream, onChunk) {\r\n    const reader = stream.getReader();\r\n    let result;\r\n    while (!(result = await reader.read()).done) {\r\n        onChunk(result.value);\r\n    }\r\n}\r\nexport function getLines(onLine) {\r\n    let buffer;\r\n    let position;\r\n    let fieldLength;\r\n    let discardTrailingNewline = false;\r\n    return function onChunk(arr) {\r\n        if (buffer === undefined) {\r\n            buffer = arr;\r\n            position = 0;\r\n            fieldLength = -1;\r\n        }\r\n        else {\r\n            buffer = concat(buffer, arr);\r\n        }\r\n        const bufLength = buffer.length;\r\n        let lineStart = 0;\r\n        while (position < bufLength) {\r\n            if (discardTrailingNewline) {\r\n                if (buffer[position] === 10) {\r\n                    lineStart = ++position;\r\n                }\r\n                discardTrailingNewline = false;\r\n            }\r\n            let lineEnd = -1;\r\n            for (; position < bufLength && lineEnd === -1; ++position) {\r\n                switch (buffer[position]) {\r\n                    case 58:\r\n                        if (fieldLength === -1) {\r\n                            fieldLength = position - lineStart;\r\n                        }\r\n                        break;\r\n                    case 13:\r\n                        discardTrailingNewline = true;\r\n                    case 10:\r\n                        lineEnd = position;\r\n                        break;\r\n                }\r\n            }\r\n            if (lineEnd === -1) {\r\n                break;\r\n            }\r\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\r\n            lineStart = position;\r\n            fieldLength = -1;\r\n        }\r\n        if (lineStart === bufLength) {\r\n            buffer = undefined;\r\n        }\r\n        else if (lineStart !== 0) {\r\n            buffer = buffer.subarray(lineStart);\r\n            position -= lineStart;\r\n        }\r\n    };\r\n}\r\nexport function getMessages(onId, onRetry, onMessage) {\r\n    let message = newMessage();\r\n    const decoder = new TextDecoder();\r\n    return function onLine(line, fieldLength) {\r\n        if (line.length === 0) {\r\n            onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);\r\n            message = newMessage();\r\n        }\r\n        else if (fieldLength > 0) {\r\n            const field = decoder.decode(line.subarray(0, fieldLength));\r\n            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);\r\n            const value = decoder.decode(line.subarray(valueOffset));\r\n            switch (field) {\r\n                case 'data':\r\n                    message.data = message.data\r\n                        ? message.data + '\\n' + value\r\n                        : value;\r\n                    break;\r\n                case 'event':\r\n                    message.event = value;\r\n                    break;\r\n                case 'id':\r\n                    onId(message.id = value);\r\n                    break;\r\n                case 'retry':\r\n                    const retry = parseInt(value, 10);\r\n                    if (!isNaN(retry)) {\r\n                        onRetry(message.retry = retry);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction concat(a, b) {\r\n    const res = new Uint8Array(a.length + b.length);\r\n    res.set(a);\r\n    res.set(b, a.length);\r\n    return res;\r\n}\r\nfunction newMessage() {\r\n    return {\r\n        data: '',\r\n        event: '',\r\n        id: '',\r\n        retry: undefined,\r\n    };\r\n}\r\n//# sourceMappingURL=parse.js.map", "var __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nimport { getBytes, getLines, getMessages } from './parse';\r\nexport const EventStreamContentType = 'text/event-stream';\r\nconst DefaultRetryInterval = 1000;\r\nconst LastEventId = 'last-event-id';\r\nexport function fetchEventSource(input, _a) {\r\n    var { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch } = _a, rest = __rest(_a, [\"signal\", \"headers\", \"onopen\", \"onmessage\", \"onclose\", \"onerror\", \"openWhenHidden\", \"fetch\"]);\r\n    return new Promise((resolve, reject) => {\r\n        const headers = Object.assign({}, inputHeaders);\r\n        if (!headers.accept) {\r\n            headers.accept = EventStreamContentType;\r\n        }\r\n        let curRequestController;\r\n        function onVisibilityChange() {\r\n            curRequestController.abort();\r\n            if (!document.hidden) {\r\n                create();\r\n            }\r\n        }\r\n        if (!openWhenHidden) {\r\n            document.addEventListener('visibilitychange', onVisibilityChange);\r\n        }\r\n        let retryInterval = DefaultRetryInterval;\r\n        let retryTimer = 0;\r\n        function dispose() {\r\n            document.removeEventListener('visibilitychange', onVisibilityChange);\r\n            window.clearTimeout(retryTimer);\r\n            curRequestController.abort();\r\n        }\r\n        inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener('abort', () => {\r\n            dispose();\r\n            resolve();\r\n        });\r\n        const fetch = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;\r\n        const onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;\r\n        async function create() {\r\n            var _a;\r\n            curRequestController = new AbortController();\r\n            try {\r\n                const response = await fetch(input, Object.assign(Object.assign({}, rest), { headers, signal: curRequestController.signal }));\r\n                await onopen(response);\r\n                await getBytes(response.body, getLines(getMessages(id => {\r\n                    if (id) {\r\n                        headers[LastEventId] = id;\r\n                    }\r\n                    else {\r\n                        delete headers[LastEventId];\r\n                    }\r\n                }, retry => {\r\n                    retryInterval = retry;\r\n                }, onmessage)));\r\n                onclose === null || onclose === void 0 ? void 0 : onclose();\r\n                dispose();\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                if (!curRequestController.signal.aborted) {\r\n                    try {\r\n                        const interval = (_a = onerror === null || onerror === void 0 ? void 0 : onerror(err)) !== null && _a !== void 0 ? _a : retryInterval;\r\n                        window.clearTimeout(retryTimer);\r\n                        retryTimer = window.setTimeout(create, interval);\r\n                    }\r\n                    catch (innerErr) {\r\n                        dispose();\r\n                        reject(innerErr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        create();\r\n    });\r\n}\r\nfunction defaultOnOpen(response) {\r\n    const contentType = response.headers.get('content-type');\r\n    if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(EventStreamContentType))) {\r\n        throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);\r\n    }\r\n}\r\n//# sourceMappingURL=fetch.js.map", "export function camelize(str: string) {\n  return str\n    .replace(/\\s(.)/g, function ($1: string) {\n      return $1.toUpperCase();\n    })\n    .replace(/\\s/g, '')\n    .replace(/^(.)/, function ($1: string) {\n      return $1.toLowerCase();\n    });\n}\n\nexport function uncamelize(str: string, separator = '-') {\n  // Replace all capital letters by separator followed by lowercase one\n  var str = str.replace(/[A-Z]/g, function (letter: string) {\n    return separator + letter.toLowerCase();\n  });\n  return str.replace(new RegExp('^' + separator), '');\n}\n\n/**\n * Returns a hex string of given length.\n *\n * Poached from StackOverflow.\n *\n * @param len Length of hex string to return.\n */\nexport function hexString(len: number): string {\n  const maxlen = 8;\n  const min = Math.pow(16, Math.min(len, maxlen) - 1);\n  const max = Math.pow(16, Math.min(len, maxlen)) - 1;\n  const n = Math.floor(Math.random() * (max - min + 1)) + min;\n  let r = n.toString(16);\n  while (r.length < len) {\n    r = r + hexString(len - maxlen);\n  }\n  return r;\n}\n\n/**\n * Generates a random UID.\n *\n * Copied from https://github.com/urbit/urbit/blob/137e4428f617c13f28ed31e520eff98d251ed3e9/pkg/interface/src/lib/util.js#L3\n */\nexport function uid(): string {\n  let str = '0v';\n  str += Math.ceil(Math.random() * 8) + '.';\n  for (let i = 0; i < 5; i++) {\n    let _str = Math.ceil(Math.random() * 10000000).toString(32);\n    _str = ('00000' + _str).substr(-5, 5);\n    str += _str + '.';\n  }\n  return str.slice(0, -1);\n}\n", "import { isBrowser, isNode } from 'browser-or-node';\nimport {\n  fetchEventSource,\n  EventSourceMessage,\n} from '@microsoft/fetch-event-source';\n\nimport {\n  Scry,\n  Thread,\n  AuthenticationInterface,\n  PokeInterface,\n  SubscriptionRequestInterface,\n  headers,\n  SSEOptions,\n  PokeHandlers,\n  Message,\n  FatalError,\n} from './types';\nimport { hexString } from './utils';\n\n/**\n * A class for interacting with an urbit ship, given its URL and code\n */\nexport class Urbit {\n  /**\n   * UID will be used for the channel: The current unix time plus a random hex string\n   */\n  private uid: string = `${Math.floor(Date.now() / 1000)}-${hexString(6)}`;\n\n  /**\n   * lastEventId is an auto-updated index of which events have been *sent* over this channel.\n   * lastHeardEventId is the latest event we have heard back about.\n   * lastAcknowledgedEventId is the latest event we have sent an ack for.\n   */\n  private lastEventId: number = 0;\n  private lastHeardEventId: number = -1;\n  private lastAcknowledgedEventId: number = -1;\n\n  /**\n   * SSE Client is null for now; we don't want to start polling until it the channel exists\n   */\n  private sseClientInitialized: boolean = false;\n\n  /**\n   * Cookie gets set when we log in.\n   */\n  cookie?: string | undefined;\n\n  /**\n   * A registry of requestId to successFunc/failureFunc\n   *\n   * These functions are registered during a +poke and are executed\n   * in the onServerEvent()/onServerError() callbacks. Only one of\n   * the functions will be called, and the outstanding poke will be\n   * removed after calling the success or failure function.\n   */\n\n  private outstandingPokes: Map<number, PokeHandlers> = new Map();\n\n  /**\n   * A registry of requestId to subscription functions.\n   *\n   * These functions are registered during a +subscribe and are\n   * executed in the onServerEvent()/onServerError() callbacks. The\n   * event function will be called whenever a new piece of data on this\n   * subscription is available, which may be 0, 1, or many times. The\n   * disconnect function may be called exactly once.\n   */\n  private outstandingSubscriptions: Map<number, SubscriptionRequestInterface> =\n    new Map();\n\n  /**\n   * Our abort controller, used to close the connection\n   */\n  private abort = new AbortController();\n\n  /**\n   * Ship can be set, in which case we can do some magic stuff like send chats\n   */\n  ship?: string | null;\n\n  /**\n   * If verbose, logs output eagerly.\n   */\n  verbose?: boolean;\n\n  /**\n   * number of consecutive errors in connecting to the eventsource\n   */\n  private errorCount = 0;\n\n  onError?: (error: any) => void = null;\n\n  onRetry?: () => void = null;\n\n  onOpen?: () => void = null;\n\n  /** This is basic interpolation to get the channel URL of an instantiated Urbit connection. */\n  private get channelUrl(): string {\n    return `${this.url}/~/channel/${this.uid}`;\n  }\n\n  private get fetchOptions(): any {\n    const headers: headers = {\n      'Content-Type': 'application/json',\n    };\n    if (!isBrowser) {\n      headers.Cookie = this.cookie;\n    }\n    return {\n      credentials: 'include',\n      accept: '*',\n      headers,\n      signal: this.abort.signal,\n    };\n  }\n\n  /**\n   * Constructs a new Urbit connection.\n   *\n   * @param url  The URL (with protocol and port) of the ship to be accessed. If\n   * the airlock is running in a webpage served by the ship, this should just\n   * be the empty string.\n   * @param code The access code for the ship at that address\n   */\n  constructor(public url: string, public code?: string, public desk?: string) {\n    if (isBrowser) {\n      window.addEventListener('beforeunload', this.delete);\n    }\n    return this;\n  }\n\n  /**\n   * All-in-one hook-me-up.\n   *\n   * Given a ship, url, and code, this returns an airlock connection\n   * that is ready to go. It `|hi`s itself to create the channel,\n   * then opens the channel via EventSource.\n   *\n   */\n  static async authenticate({\n    ship,\n    url,\n    code,\n    verbose = false,\n  }: AuthenticationInterface) {\n    const airlock = new Urbit(url.startsWith('http') ? url : `http://${url}`, code);\n    airlock.verbose = verbose;\n    airlock.ship = ship;\n    await airlock.connect();\n    await airlock.poke({\n      app: 'hood',\n      mark: 'helm-hi',\n      json: 'opening airlock',\n    });\n    await airlock.eventSource();\n    return airlock;\n  }\n\n  /**\n   * Connects to the Urbit ship. Nothing can be done until this is called.\n   * That's why we roll it into this.authenticate\n   */\n  async connect(): Promise<void> {\n    if (this.verbose) {\n      console.log(\n        `password=${this.code} `,\n        isBrowser\n          ? 'Connecting in browser context at ' + `${this.url}/~/login`\n          : 'Connecting from node context'\n      );\n    }\n    return fetch(`${this.url}/~/login`, {\n      method: 'post',\n      body: `password=${this.code}`,\n      credentials: 'include',\n    }).then((response) => {\n      if (this.verbose) {\n        console.log('Received authentication response', response);\n      }\n      const cookie = response.headers.get('set-cookie');\n      if (!this.ship) {\n        this.ship = new RegExp(/urbauth-~([\\w-]+)/).exec(cookie)[1];\n      }\n      if (!isBrowser) {\n        this.cookie = cookie;\n      }\n    });\n  }\n\n  /**\n   * Initializes the SSE pipe for the appropriate channel.\n   */\n  async eventSource(): Promise<void> {\n    if (this.sseClientInitialized) {\n      return Promise.resolve();\n    }\n    if (this.lastEventId === 0) {\n      // Can't receive events until the channel is open,\n      // so poke and open then\n      await this.poke({\n        app: 'hood',\n        mark: 'helm-hi',\n        json: 'Opening API channel',\n      });\n      return;\n    }\n    this.sseClientInitialized = true;\n    return new Promise((resolve, reject) => {\n      const sseOptions: SSEOptions = {\n        headers: {},\n      };\n      if (isBrowser) {\n        sseOptions.withCredentials = true;\n      } else if (isNode) {\n        sseOptions.headers.Cookie = this.cookie;\n      }\n      fetchEventSource(this.channelUrl, {\n        ...this.fetchOptions,\n        openWhenHidden: true,\n        onopen: async (response) => {\n          if (this.verbose) {\n            console.log('Opened eventsource', response);\n          }\n          if (response.ok) {\n            this.errorCount = 0;\n            this.onOpen && this.onOpen();\n            resolve();\n            return; // everything's good\n          } else {\n            const err = new Error('failed to open eventsource');\n            reject(err);\n          }\n        },\n        onmessage: (event: EventSourceMessage) => {\n          if (this.verbose) {\n            console.log('Received SSE: ', event);\n          }\n          if (!event.id) return;\n          const eventId = parseInt(event.id, 10);\n          if (eventId <= this.lastHeardEventId) {\n            console.log('dropping old or out-of-order event', {\n              eventId, lastHeard: this.lastHeardEventId\n            });\n            return;\n          }\n          this.lastHeardEventId = eventId;\n          if (eventId - this.lastAcknowledgedEventId > 20) {\n            this.ack(eventId);\n          }\n\n          if (event.data && JSON.parse(event.data)) {\n            const data: any = JSON.parse(event.data);\n\n            if (\n              data.response === 'poke' &&\n              this.outstandingPokes.has(data.id)\n            ) {\n              const funcs = this.outstandingPokes.get(data.id);\n              if (data.hasOwnProperty('ok')) {\n                funcs.onSuccess();\n              } else if (data.hasOwnProperty('err')) {\n                console.error(data.err);\n                funcs.onError(data.err);\n              } else {\n                console.error('Invalid poke response', data);\n              }\n              this.outstandingPokes.delete(data.id);\n            } else if (\n              data.response === 'subscribe' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              if (data.hasOwnProperty('err')) {\n                console.error(data.err);\n                funcs.err(data.err, data.id);\n                this.outstandingSubscriptions.delete(data.id);\n              }\n            } else if (\n              data.response === 'diff' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              try {\n                funcs.event(data.json, data.mark ?? 'json');\n              } catch (e) {\n                console.error('Failed to call subscription event callback', e);\n              }\n            } else if (\n              data.response === 'quit' &&\n              this.outstandingSubscriptions.has(data.id)\n            ) {\n              const funcs = this.outstandingSubscriptions.get(data.id);\n              funcs.quit(data);\n              this.outstandingSubscriptions.delete(data.id);\n            } else {\n              console.log([...this.outstandingSubscriptions.keys()]);\n              console.log('Unrecognized response', data);\n            }\n          }\n        },\n        onerror: (error) => {\n          console.warn(error);\n          if (!(error instanceof FatalError) && this.errorCount++ < 4) {\n            this.onRetry && this.onRetry();\n            return Math.pow(2, this.errorCount - 1) * 750;\n          }\n          this.onError && this.onError(error);\n          throw error;\n        },\n        onclose: () => {\n          console.log('e');\n          throw new Error('Ship unexpectedly closed the connection');\n        },\n      });\n    });\n  }\n\n  /**\n   * Reset airlock, abandoning current subscriptions and wiping state\n   *\n   */\n  reset() {\n    if (this.verbose) {\n      console.log('resetting');\n    }\n    this.delete();\n    this.abort.abort();\n    this.abort = new AbortController();\n    this.uid = `${Math.floor(Date.now() / 1000)}-${hexString(6)}`;\n    this.lastEventId = 0;\n    this.lastHeardEventId = -1;\n    this.lastAcknowledgedEventId = -1;\n    this.outstandingSubscriptions = new Map();\n    this.outstandingPokes = new Map();\n    this.sseClientInitialized = false;\n  }\n\n  /**\n   * Autoincrements the next event ID for the appropriate channel.\n   */\n  private getEventId(): number {\n    return ++this.lastEventId;\n  }\n\n  /**\n   * Acknowledges an event.\n   *\n   * @param eventId The event to acknowledge.\n   */\n  private async ack(eventId: number): Promise<number | void> {\n    this.lastAcknowledgedEventId = eventId;\n    const message: Message = {\n      action: 'ack',\n      'event-id': eventId,\n    };\n    await this.sendJSONtoChannel(message);\n    return eventId;\n  }\n\n  private async sendJSONtoChannel(...json: Message[]): Promise<void> {\n    const response = await fetch(this.channelUrl, {\n      ...this.fetchOptions,\n      method: 'PUT',\n      body: JSON.stringify(json),\n    });\n    if (!response.ok) {\n      throw new Error('Failed to PUT channel');\n    }\n    if (!this.sseClientInitialized) {\n      await this.eventSource();\n    }\n  }\n\n  /**\n   * Creates a subscription, waits for a fact and then unsubscribes\n   *\n   * @param app Name of gall agent to subscribe to\n   * @param path Path to subscribe to\n   * @param timeout Optional timeout before ending subscription\n   *\n   * @returns The first fact on the subcription\n   */\n  async subscribeOnce<T = any>(app: string, path: string, timeout?: number) {\n    return new Promise<T>(async (resolve, reject) => {\n      let done = false;\n      let id: number | null = null;\n      const quit = () => {\n        if (!done) {\n          reject('quit');\n        }\n      };\n      const event = (e: T) => {\n        if (!done) {\n          resolve(e);\n          this.unsubscribe(id);\n        }\n      };\n      const request = { app, path, event, err: reject, quit };\n\n      id = await this.subscribe(request);\n\n      if (timeout) {\n        setTimeout(() => {\n          if (!done) {\n            done = true;\n            reject('timeout');\n            this.unsubscribe(id);\n          }\n        }, timeout);\n      }\n    });\n  }\n\n  /**\n   * Pokes a ship with data.\n   *\n   * @param app The app to poke\n   * @param mark The mark of the data being sent\n   * @param json The data to send\n   */\n  async poke<T>(params: PokeInterface<T>): Promise<number> {\n    const { app, mark, json, ship, onSuccess, onError } = {\n      onSuccess: () => {},\n      onError: () => {},\n      ship: this.ship,\n      ...params,\n    };\n    const message: Message = {\n      id: this.getEventId(),\n      action: 'poke',\n      ship,\n      app,\n      mark,\n      json,\n    };\n    const [send, result] = await Promise.all([\n      this.sendJSONtoChannel(message),\n      new Promise<number>((resolve, reject) => {\n        this.outstandingPokes.set(message.id, {\n          onSuccess: () => {\n            onSuccess();\n            resolve(message.id);\n          },\n          onError: (event) => {\n            onError(event);\n            reject(event.err);\n          },\n        });\n      }),\n    ]);\n    return result;\n  }\n\n  /**\n   * Subscribes to a path on an app on a ship.\n   *\n   *\n   * @param app The app to subsribe to\n   * @param path The path to which to subscribe\n   * @param handlers Handlers to deal with various events of the subscription\n   */\n  async subscribe(params: SubscriptionRequestInterface): Promise<number> {\n    const { app, path, ship, err, event, quit } = {\n      err: () => {},\n      event: () => {},\n      quit: () => {},\n      ship: this.ship,\n      ...params,\n    };\n\n    const message: Message = {\n      id: this.getEventId(),\n      action: 'subscribe',\n      ship,\n      app,\n      path,\n    };\n\n    this.outstandingSubscriptions.set(message.id, {\n      app,\n      path,\n      err,\n      event,\n      quit,\n    });\n\n    await this.sendJSONtoChannel(message);\n\n    return message.id;\n  }\n\n  /**\n   * Unsubscribes to a given subscription.\n   *\n   * @param subscription\n   */\n  async unsubscribe(subscription: number) {\n    return this.sendJSONtoChannel({\n      id: this.getEventId(),\n      action: 'unsubscribe',\n      subscription,\n    }).then(() => {\n      this.outstandingSubscriptions.delete(subscription);\n    });\n  }\n\n  /**\n   * Deletes the connection to a channel.\n   */\n  delete() {\n    if (isBrowser) {\n      navigator.sendBeacon(\n        this.channelUrl,\n        JSON.stringify([\n          {\n            action: 'delete',\n          },\n        ])\n      );\n    } else {\n      // TODO\n      // this.sendMessage('delete');\n    }\n  }\n\n  /**\n   * Scry into an gall agent at a path\n   *\n   * @typeParam T - Type of the scry result\n   *\n   * @remarks\n   *\n   * Equivalent to\n   * ```hoon\n   * .^(T %gx /(scot %p our)/[app]/(scot %da now)/[path]/json)\n   * ```\n   * The returned cage must have a conversion to JSON for the scry to succeed\n   *\n   * @param params The scry request\n   * @returns The scry result\n   */\n  async scry<T = any>(params: Scry): Promise<T> {\n    const { app, path } = params;\n    const response = await fetch(\n      `${this.url}/~/scry/${app}${path}.json`,\n      this.fetchOptions\n    )\n\n    if (!response.ok) {\n      return Promise.reject(response);\n    }\n\n    return await response.json();\n  }\n\n  /**\n   * Run a thread\n   *\n   *\n   * @param inputMark   The mark of the data being sent\n   * @param outputMark  The mark of the data being returned\n   * @param threadName  The thread to run\n   * @param body        The data to send to the thread\n   * @returns  The return value of the thread\n   */\n  async thread<R, T = any>(params: Thread<T>): Promise<R> {\n    const {\n      inputMark,\n      outputMark,\n      threadName,\n      body,\n      desk = this.desk,\n    } = params;\n    if (!desk) {\n      throw new Error('Must supply desk to run thread from');\n    }\n    const res = await fetch(\n      `${this.url}/spider/${desk}/${inputMark}/${threadName}/${outputMark}.json`,\n      {\n        ...this.fetchOptions,\n        method: 'POST',\n        body: JSON.stringify(body),\n      }\n    );\n\n    return res.json();\n  }\n\n  /**\n   * Utility function to connect to a ship that has its *.arvo.network domain configured.\n   *\n   * @param name Name of the ship e.g. zod\n   * @param code Code to log in\n   */\n  static async onArvoNetwork(ship: string, code: string): Promise<Urbit> {\n    const url = `https://${ship}.arvo.network`;\n    return await Urbit.authenticate({ ship, url, code });\n  }\n}\n\nexport default Urbit;\n", "import d from \"./node_modules/@urbit/http-api/dist/esm/index.js\";export default d;\nexport * from \"./node_modules/@urbit/http-api/dist/esm/index.js\""],
  "mappings": "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",
  "names": ["isJsDom", "fetch", "_a", "isBrowser"]
}
