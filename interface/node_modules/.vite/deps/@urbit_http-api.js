import "./chunk-IVLCYF2H.js";

// node_modules/@urbit/http-api/dist/esm/index.js
var ResumableError = class extends Error {
};
var FatalError = class extends Error {
};
var lib = {};
Object.defineProperty(lib, "__esModule", {
  value: true
});
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker = (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
var isJsDom = function isJsDom2() {
  return typeof window !== "undefined" && window.name === "nodejs" || navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
};
var isBrowser_1 = lib.isBrowser = isBrowser;
lib.isWebWorker = isWebWorker;
lib.isNode = isNode;
lib.isJsDom = isJsDom;
async function getBytes(stream, onChunk) {
  const reader = stream.getReader();
  let result;
  while (!(result = await reader.read()).done) {
    onChunk(result.value);
  }
}
function getLines(onLine) {
  let buffer;
  let position;
  let fieldLength;
  let discardTrailingNewline = false;
  return function onChunk(arr) {
    if (buffer === void 0) {
      buffer = arr;
      position = 0;
      fieldLength = -1;
    } else {
      buffer = concat(buffer, arr);
    }
    const bufLength = buffer.length;
    let lineStart = 0;
    while (position < bufLength) {
      if (discardTrailingNewline) {
        if (buffer[position] === 10) {
          lineStart = ++position;
        }
        discardTrailingNewline = false;
      }
      let lineEnd = -1;
      for (; position < bufLength && lineEnd === -1; ++position) {
        switch (buffer[position]) {
          case 58:
            if (fieldLength === -1) {
              fieldLength = position - lineStart;
            }
            break;
          case 13:
            discardTrailingNewline = true;
          case 10:
            lineEnd = position;
            break;
        }
      }
      if (lineEnd === -1) {
        break;
      }
      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);
      lineStart = position;
      fieldLength = -1;
    }
    if (lineStart === bufLength) {
      buffer = void 0;
    } else if (lineStart !== 0) {
      buffer = buffer.subarray(lineStart);
      position -= lineStart;
    }
  };
}
function getMessages(onId, onRetry, onMessage) {
  let message = newMessage();
  const decoder = new TextDecoder();
  return function onLine(line, fieldLength) {
    if (line.length === 0) {
      onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);
      message = newMessage();
    } else if (fieldLength > 0) {
      const field = decoder.decode(line.subarray(0, fieldLength));
      const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);
      const value = decoder.decode(line.subarray(valueOffset));
      switch (field) {
        case "data":
          message.data = message.data ? message.data + "\n" + value : value;
          break;
        case "event":
          message.event = value;
          break;
        case "id":
          onId(message.id = value);
          break;
        case "retry":
          const retry = parseInt(value, 10);
          if (!isNaN(retry)) {
            onRetry(message.retry = retry);
          }
          break;
      }
    }
  };
}
function concat(a, b) {
  const res = new Uint8Array(a.length + b.length);
  res.set(a);
  res.set(b, a.length);
  return res;
}
function newMessage() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var EventStreamContentType = "text/event-stream";
var DefaultRetryInterval = 1e3;
var LastEventId = "last-event-id";
function fetchEventSource(input, _a) {
  var { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch } = _a, rest = __rest(_a, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"]);
  return new Promise((resolve, reject) => {
    const headers = Object.assign({}, inputHeaders);
    if (!headers.accept) {
      headers.accept = EventStreamContentType;
    }
    let curRequestController;
    function onVisibilityChange() {
      curRequestController.abort();
      if (!document.hidden) {
        create();
      }
    }
    if (!openWhenHidden) {
      document.addEventListener("visibilitychange", onVisibilityChange);
    }
    let retryInterval = DefaultRetryInterval;
    let retryTimer = 0;
    function dispose() {
      document.removeEventListener("visibilitychange", onVisibilityChange);
      window.clearTimeout(retryTimer);
      curRequestController.abort();
    }
    inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener("abort", () => {
      dispose();
      resolve();
    });
    const fetch2 = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;
    const onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;
    async function create() {
      var _a2;
      curRequestController = new AbortController();
      try {
        const response = await fetch2(input, Object.assign(Object.assign({}, rest), { headers, signal: curRequestController.signal }));
        await onopen(response);
        await getBytes(response.body, getLines(getMessages((id) => {
          if (id) {
            headers[LastEventId] = id;
          } else {
            delete headers[LastEventId];
          }
        }, (retry) => {
          retryInterval = retry;
        }, onmessage)));
        onclose === null || onclose === void 0 ? void 0 : onclose();
        dispose();
        resolve();
      } catch (err) {
        if (!curRequestController.signal.aborted) {
          try {
            const interval = (_a2 = onerror === null || onerror === void 0 ? void 0 : onerror(err)) !== null && _a2 !== void 0 ? _a2 : retryInterval;
            window.clearTimeout(retryTimer);
            retryTimer = window.setTimeout(create, interval);
          } catch (innerErr) {
            dispose();
            reject(innerErr);
          }
        }
      }
    }
    create();
  });
}
function defaultOnOpen(response) {
  const contentType = response.headers.get("content-type");
  if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(EventStreamContentType))) {
    throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);
  }
}
function hexString(len) {
  const maxlen = 8;
  const min = Math.pow(16, Math.min(len, maxlen) - 1);
  const max = Math.pow(16, Math.min(len, maxlen)) - 1;
  const n = Math.floor(Math.random() * (max - min + 1)) + min;
  let r = n.toString(16);
  while (r.length < len) {
    r = r + hexString(len - maxlen);
  }
  return r;
}
var Urbit = class {
  constructor(url, code, desk) {
    this.url = url;
    this.code = code;
    this.desk = desk;
    this.uid = `${Math.floor(Date.now() / 1e3)}-${hexString(6)}`;
    this.lastEventId = 0;
    this.lastHeardEventId = -1;
    this.lastAcknowledgedEventId = -1;
    this.sseClientInitialized = false;
    this.outstandingPokes = /* @__PURE__ */ new Map();
    this.outstandingSubscriptions = /* @__PURE__ */ new Map();
    this.abort = new AbortController();
    this.errorCount = 0;
    this.onError = null;
    this.onRetry = null;
    this.onOpen = null;
    if (isBrowser_1) {
      window.addEventListener("beforeunload", this.delete);
    }
    return this;
  }
  get channelUrl() {
    return `${this.url}/~/channel/${this.uid}`;
  }
  get fetchOptions() {
    const headers = {
      "Content-Type": "application/json"
    };
    if (!isBrowser_1) {
      headers.Cookie = this.cookie;
    }
    return {
      credentials: "include",
      accept: "*",
      headers,
      signal: this.abort.signal
    };
  }
  static async authenticate({ ship, url, code, verbose = false }) {
    const airlock = new Urbit(url.startsWith("http") ? url : `http://${url}`, code);
    airlock.verbose = verbose;
    airlock.ship = ship;
    await airlock.connect();
    await airlock.poke({
      app: "hood",
      mark: "helm-hi",
      json: "opening airlock"
    });
    await airlock.eventSource();
    return airlock;
  }
  async connect() {
    if (this.verbose) {
      console.log(`password=${this.code} `, isBrowser_1 ? `Connecting in browser context at ${this.url}/~/login` : "Connecting from node context");
    }
    return fetch(`${this.url}/~/login`, {
      method: "post",
      body: `password=${this.code}`,
      credentials: "include"
    }).then((response) => {
      if (this.verbose) {
        console.log("Received authentication response", response);
      }
      const cookie = response.headers.get("set-cookie");
      if (!this.ship) {
        this.ship = new RegExp(/urbauth-~([\w-]+)/).exec(cookie)[1];
      }
      if (!isBrowser_1) {
        this.cookie = cookie;
      }
    });
  }
  async eventSource() {
    if (this.sseClientInitialized) {
      return Promise.resolve();
    }
    if (this.lastEventId === 0) {
      await this.poke({
        app: "hood",
        mark: "helm-hi",
        json: "Opening API channel"
      });
      return;
    }
    this.sseClientInitialized = true;
    return new Promise((resolve, reject) => {
      fetchEventSource(this.channelUrl, {
        ...this.fetchOptions,
        openWhenHidden: true,
        onopen: async (response) => {
          if (this.verbose) {
            console.log("Opened eventsource", response);
          }
          if (response.ok) {
            this.errorCount = 0;
            this.onOpen && this.onOpen();
            resolve();
            return;
          } else {
            const err = new Error("failed to open eventsource");
            reject(err);
          }
        },
        onmessage: (event) => {
          var _a;
          if (this.verbose) {
            console.log("Received SSE: ", event);
          }
          if (!event.id)
            return;
          const eventId = parseInt(event.id, 10);
          if (eventId <= this.lastHeardEventId) {
            console.log("dropping old or out-of-order event", {
              eventId,
              lastHeard: this.lastHeardEventId
            });
            return;
          }
          this.lastHeardEventId = eventId;
          if (eventId - this.lastAcknowledgedEventId > 20) {
            this.ack(eventId);
          }
          if (event.data && JSON.parse(event.data)) {
            const data = JSON.parse(event.data);
            if (data.response === "poke" && this.outstandingPokes.has(data.id)) {
              const funcs = this.outstandingPokes.get(data.id);
              if (data.hasOwnProperty("ok")) {
                funcs.onSuccess();
              } else if (data.hasOwnProperty("err")) {
                console.error(data.err);
                funcs.onError(data.err);
              } else {
                console.error("Invalid poke response", data);
              }
              this.outstandingPokes.delete(data.id);
            } else if (data.response === "subscribe" && this.outstandingSubscriptions.has(data.id)) {
              const funcs = this.outstandingSubscriptions.get(data.id);
              if (data.hasOwnProperty("err")) {
                console.error(data.err);
                funcs.err(data.err, data.id);
                this.outstandingSubscriptions.delete(data.id);
              }
            } else if (data.response === "diff" && this.outstandingSubscriptions.has(data.id)) {
              const funcs = this.outstandingSubscriptions.get(data.id);
              try {
                funcs.event(data.json, (_a = data.mark) != null ? _a : "json");
              } catch (e) {
                console.error("Failed to call subscription event callback", e);
              }
            } else if (data.response === "quit" && this.outstandingSubscriptions.has(data.id)) {
              const funcs = this.outstandingSubscriptions.get(data.id);
              funcs.quit(data);
              this.outstandingSubscriptions.delete(data.id);
            } else {
              console.log([...this.outstandingSubscriptions.keys()]);
              console.log("Unrecognized response", data);
            }
          }
        },
        onerror: (error) => {
          console.warn(error);
          if (!(error instanceof FatalError) && this.errorCount++ < 4) {
            this.onRetry && this.onRetry();
            return Math.pow(2, this.errorCount - 1) * 750;
          }
          this.onError && this.onError(error);
          throw error;
        },
        onclose: () => {
          console.log("e");
          throw new Error("Ship unexpectedly closed the connection");
        }
      });
    });
  }
  reset() {
    if (this.verbose) {
      console.log("resetting");
    }
    this.delete();
    this.abort.abort();
    this.abort = new AbortController();
    this.uid = `${Math.floor(Date.now() / 1e3)}-${hexString(6)}`;
    this.lastEventId = 0;
    this.lastHeardEventId = -1;
    this.lastAcknowledgedEventId = -1;
    this.outstandingSubscriptions = /* @__PURE__ */ new Map();
    this.outstandingPokes = /* @__PURE__ */ new Map();
    this.sseClientInitialized = false;
  }
  getEventId() {
    return ++this.lastEventId;
  }
  async ack(eventId) {
    this.lastAcknowledgedEventId = eventId;
    const message = {
      action: "ack",
      "event-id": eventId
    };
    await this.sendJSONtoChannel(message);
    return eventId;
  }
  async sendJSONtoChannel(...json) {
    const response = await fetch(this.channelUrl, {
      ...this.fetchOptions,
      method: "PUT",
      body: JSON.stringify(json)
    });
    if (!response.ok) {
      throw new Error("Failed to PUT channel");
    }
    if (!this.sseClientInitialized) {
      await this.eventSource();
    }
  }
  async subscribeOnce(app, path, timeout) {
    return new Promise(async (resolve, reject) => {
      let done = false;
      let id = null;
      const quit = () => {
        if (!done) {
          reject("quit");
        }
      };
      const event = (e) => {
        if (!done) {
          resolve(e);
          this.unsubscribe(id);
        }
      };
      const request = { app, path, event, err: reject, quit };
      id = await this.subscribe(request);
      if (timeout) {
        setTimeout(() => {
          if (!done) {
            done = true;
            reject("timeout");
            this.unsubscribe(id);
          }
        }, timeout);
      }
    });
  }
  async poke(params) {
    const { app, mark, json, ship, onSuccess, onError } = {
      onSuccess: () => {
      },
      onError: () => {
      },
      ship: this.ship,
      ...params
    };
    const message = {
      id: this.getEventId(),
      action: "poke",
      ship,
      app,
      mark,
      json
    };
    const [send, result] = await Promise.all([
      this.sendJSONtoChannel(message),
      new Promise((resolve, reject) => {
        this.outstandingPokes.set(message.id, {
          onSuccess: () => {
            onSuccess();
            resolve(message.id);
          },
          onError: (event) => {
            onError(event);
            reject(event.err);
          }
        });
      })
    ]);
    return result;
  }
  async subscribe(params) {
    const { app, path, ship, err, event, quit } = {
      err: () => {
      },
      event: () => {
      },
      quit: () => {
      },
      ship: this.ship,
      ...params
    };
    const message = {
      id: this.getEventId(),
      action: "subscribe",
      ship,
      app,
      path
    };
    this.outstandingSubscriptions.set(message.id, {
      app,
      path,
      err,
      event,
      quit
    });
    await this.sendJSONtoChannel(message);
    return message.id;
  }
  async unsubscribe(subscription) {
    return this.sendJSONtoChannel({
      id: this.getEventId(),
      action: "unsubscribe",
      subscription
    }).then(() => {
      this.outstandingSubscriptions.delete(subscription);
    });
  }
  delete() {
    if (isBrowser_1) {
      navigator.sendBeacon(this.channelUrl, JSON.stringify([
        {
          action: "delete"
        }
      ]));
    }
  }
  async scry(params) {
    const { app, path } = params;
    const response = await fetch(`${this.url}/~/scry/${app}${path}.json`, this.fetchOptions);
    if (!response.ok) {
      return Promise.reject(response);
    }
    return await response.json();
  }
  async thread(params) {
    const { inputMark, outputMark, threadName, body, desk = this.desk } = params;
    if (!desk) {
      throw new Error("Must supply desk to run thread from");
    }
    const res = await fetch(`${this.url}/spider/${desk}/${inputMark}/${threadName}/${outputMark}.json`, {
      ...this.fetchOptions,
      method: "POST",
      body: JSON.stringify(body)
    });
    return res.json();
  }
  static async onArvoNetwork(ship, code) {
    const url = `https://${ship}.arvo.network`;
    return await Urbit.authenticate({ ship, url, code });
  }
};

// dep:@urbit_http-api
var urbit_http_api_default = Urbit;
export {
  FatalError,
  ResumableError,
  Urbit,
  urbit_http_api_default as default
};
//# sourceMappingURL=@urbit_http-api.js.map
